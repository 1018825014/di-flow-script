def run(event_dict):\n    maxDateTime_str = event_dict.get('maxDateTime', None)\n    created_at_min_str = event_dict.get('created_at_min', None)\n\n    if maxDateTime_str is not None:\n        return json.dumps({'startTimestamp': maxDateTime_str})\n    elif created_at_min_str is not None:\n        if created_at_min_str == '':\n            return json.dumps({})\n        try:\n            # Check if the timezone is 'Z' for UTC or contains offset\n            if created_at_min_str.endswith('Z'):\n                formatted_utc = created_at_min_str[:-1] + '.000Z'\n            else:\n                date_part, time_part = created_at_min_str.split('T')\n                year, month, day = map(int, date_part.split('-'))\n                if '+' in time_part:\n                    time_part, tz_part = time_part.split('+')\n                    tz_hour, tz_minute = map(int, tz_part.split(':'))\n                else:\n                    # No timezone offset provided, assume UTC\n                    tz_hour = 0\n                    tz_minute = 0\n\n                hour, minute, second = map(int, time_part.split(':'))\n\n                dt = datetime(year, month, day, hour, minute, second)\n                utc_dt = dt - timedelta(hours=tz_hour, minutes=tz_minute)\n                formatted_utc = utc_dt.strftime('%Y-%m-%dT%H:%M:%S') + '.000Z'\n\n            return json.dumps({'startTimestamp': formatted_utc})\n        except ValueError as e:\n            return json.dumps({'error': f'Invalid datetime format: {str(e)}'})\n    else:\n        return json.dumps({})